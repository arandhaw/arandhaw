---
layout: post
title: "Robotics Competition"
date: 2022-08-20
description: "Engineering Physics 2022 Robotics competition"
image: "/assets/robot_cad.png"
---

### Overview

Every summer, 2nd year Engineering Physics students are split into 16 teams that compete to win a robotics competition. For six weeks, we do nothing but robotics. I basically spent the equivalent of 6-10 hours a day for six weeks working on this thing. My team of four was able to win the competition, and it will forever be one of the most memorable moments in my university degree.

Our year, we were challenged to pick up six idols in an obstacle course. Here is the graphic of the obstacle course for our year:

<img src="/assets/robot_layout.png" alt="image" width="500"/>

The first section of course has a line of black tape which can be followed with a reflection sensor. There is then a short section of chicken wire, following by a 30x30cm archway that the robot must fit through. The first two idols are here. 

After this section, the tape disappears. Two infrared beacons at different frequencies are situated in this section. (The idea is that you filter out one of them and go in the direction of the other one). On each side of the central section, there are areas filled with rocks. An idol is placed on each side.

To get to the third section, you have to ride the zipline (a horizontal metal bar). In the third section, two circular platforms are connected by a bridge. There are two idols here as well. Finally, there is a second zipline that can be rode to the end zone. 

To gain points, we must collect idols  - there are 5 silver idols and 1 gold idol, plus extra points for reaching the end. Lastly, one of the idols is a "bomb" - if you pick it up, you explode. It is identified by a magnet placed inside. 

We were the only team to get a perfect score, and one of only 3 teams to make it to the final section.

### Design

Our team's strategy rested on making a really simple, flexible chasis, and getting a working robot as quickly as possible. That way, we were able to begin testing far earlier than the other teams. There were many ups and downs over the six weeks, but here's an overview.

Our robot had 6 types of sensors
- Reflectance sensors for the tape
- Sonar to detect the idols
- Hall affect sensors to detect the "bomb"
- Infrared sensors with a filtering circuit for the beacon
- Another set of reflectance sensors to prevent ourselves from falling off the bridge

We also used motors with rotary encoders built in. Encoders tell you the distance travelled by motors, and we used to create precise sequences of movements, especially in the third part of the course where there is no tape or beacons to the guide the robot. 

All the software was on an STM32 "blue pill" microcontroller, written in C++. 

### Mechanical Design

We wanted to make our robot as simple as possible. In this vein, our mechanical design for the robot looked like this:

<img src="/assets/robot_CAD.png" alt="image" width="500"/>

The flat sheets were laser cut, wheras the plastic parts were 3D printed or laser cut from delrin. The robot's back motors were held in place by 3D printed mounts. The front wheel was a caster wheel attached via a 3D printed mount as well. 

The advantage of our simple design is that it allowed us to begin driving around and testing our sensors on the physical course right away. Most teams overengineered their chassis, and didn't spend enough time on electronics, software and testing. A lot of groups suffered from trying to put everything together in the last week, which is basically an impossible task. 

The downside is that our robot was fairly ugly - in fact, we named it "garbage truck". This was both in line with its functionality (the robotic claw picks up idols and deposits them in the back, like its namesake) but also its philosophy - we prioritized function over form. 

### Electronics

Here, there are too many circuits to go over in detail. My team mates spent days soldering, testing, and debugging our circuits. Each motor had an H-bridge that allowed it to run both forward and in reverse. Each sensor interfaced with our microcontroller with a voltage divider. The most complex circuit was the infrared beacon circuit. My friend Gio spent a truly gargantuan amount of time getting this to work. It had to take data from infrared sensors, filter out the signal from the false beacon, and obtain the amplitude of the signal. 

My biggest contribution here was that I wrote the firmware to interface with each sensor, and helped debug the circuits that my friends built. It turns out that almost nothing works on the first try, and so I spent quite a long time getting the 7 different types of sensors to work. 

### Software

The C++ firmware that I wrote had control the following
- Two motors for driving
- Servos for the robotic claw
- 19 different sensors
- Motor for our linear actuator
- Motor to move along the zipline
- PID algorithm for following the black tape
- PID algorithm for moving towards the infrared beacon
- Algorithm to follow edge of the platforms
- Putting everything together

Like our robot, if you start in the main file of the repo, you'll probably be initially disgusted by the code. The main file contains a mess of branches, loops, and function calls that describe the exact sequence of steps the robot had to follow. Its pretty messy, and I admit its not easy to follow.

But like our robot, although the firmware is disordered from the outside, upon deeper inspection you'll find that the software is deeply structured. Unlike some other groups that didn't bother, I used object oriented programming to make our code as modular as possible. Each sensor has a class that handles interfacing with the hardware. All but the most high level interaction was abstracted away. For example, the motors could be used simply by specifying the direction, speed, and distance of travel. 

Then, certain key algorithms like the tape and beacon following had their own custom functions written to handle all the details. 

The messiness in the main file was partially because we had to madly scramble near the end of the competition, and there wasn't enough time to make the main function beautiful. However, I think this ended up working out extremely well. 

The reality is that some of the programmers on rival teams got lost in software. In order to achieve something conceptually beautiful, they neglected other important parts of the process. For example, many teams spent hours making a state machine with classes and inheritance and all that jazz. However, this doesn't actually make the software more reliable or easier to debug. Our robot's state machine was a handful of global variables, and all the sensors/motors were global as well. The key thing is that if you only have 1 robot, there's no point making it a class. Writing a state machine might make the software easier to follow for someone else, but the simplicity of our approach made it easy to iterate and quickly fix errors.

That being said, some other teams had the opposite problem. Their code had no structure at all, and was just a rats nest impossible to debug. Our team managed to strike a balance - enough abstractions to simplify programming and make debugging easy, but not overengineered to the point of wasting time.

### Competition Day

The number of teams whose robot was unable to do anything at all was astonishingly high, even though getting the first two idols is a pretty easy task. 

More to come...


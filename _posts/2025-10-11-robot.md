---
layout: post
title: "Robotics Competition"
date: 2022-08-20
description: "Engineering Physics 2022 Robotics competition"
image: "./assets/robot_cad.png"
---

### Overview

Every summer, 2nd year Engineering Physics students are split into 16 teams that compete to win a robotics competition. For six weeks, we do nothing but robotics. I basically spent the equivalent of 6-10 hours a day for six weeks working on this thing. My team of four was able to win the competition, and it will forever be one of the most memorable moments in my university degree.

Our year, we were challenged to pick up six idols in an obstacle course. Here is the graphic of the obstacle course for our year:

<img src="./assets/robot_layout.png" alt="image" width="500"/>

The first section of course has a line of black tape which can be followed with a reflection sensor. There is then a short section of chicken wire, following by a 30x30cm archway that the robot must fit through. The first two idols are here. 

After this section, the tape disappears. Two infrared beacons at different frequencies are situated in this section. (The idea is that you filter out one of them and go in the direction of the other one). On each side of the central section, there are areas filled with rocks. An idol is placed on each side.

To get to the third section, you have to ride the zipline (a horizontal metal bar). In the third section, two circular platforms are connected by a bridge. There are two idols here as well. Finally, there is a second zipline that can be rode to the end zone. 

To gain points, we must collect idols  - there are 5 silver idols and 1 gold idol, plus extra points for reaching the end. Lastly, one of the idols is a "bomb" - if you pick it up, you explode. It is identified by a magnet placed inside. 

We were the only team to get a perfect score, and one of only 3 teams to make it to the final section.

### Design

Our team's strategy rested on making a really simple, flexible chasis, and getting a working robot as quickly as possible. That way, we were able to begin testing far earlier than the other teams. There were many ups and downs over the six weeks, but here's an overview.

Our robot had 6 types of sensors
- Reflectance sensors for the tape
- Sonar to detect the idols
- Hall affect sensors to detect the "bomb"
- Infrared sensors with a filtering circuit for the beacon
- Another set of reflectance sensors to prevent ourselves from falling off the bridge

We also used motors with rotary encoders built in. Encoders tell you the distance travelled by motors, and we used to create precise sequences of movements, especially in the third part of the course where there is no tape or beacons to the guide the robot. 

All the software was on an STM32 "blue pill" microcontroller, written in C++. 

### Mechanical Design

We wanted to make our robot as simple as possible. In this vein, our mechanical design for the robot looked like this:

<img src="./assets/robot_CAD.png" alt="image" width="500"/>

The flat sheets were laser cut, wheras the plastic parts were 3D printed or laser cut from delrin. The robot's back motors were held in place by 3D printed mounts. The front wheel was a caster wheel attached via a 3D printed mount as well. 

The advantage of our simple design is that it allowed us to begin driving around and testing our sensors on the physical course right away. Most teams overengineered their chassis, and didn't spend enough time on electronics, software and testing. A lot of groups suffered from trying to put everything together in the last week, which is basically an impossible task. 

The downside is that our robot was fairly ugly - in fact, we named it "garbage truck". This was both in line with its functionality (the robotic claw picks up idols and deposits them in the back, like its namesake) but also its philosophy - we prioritized function over form. 

### Electronics

Here, there are too many circuits to go over in detail. My team mates spent days soldering, testing, and debugging our circuits. Each motor had an H-bridge that allowed it to run both forward and in reverse. Each sensor interfaced with our microcontroller with a voltage divider. The most complex circuit was the infrared beacon circuit. My friend Gio spent a truly gargantuan amount of time getting this to work. It had to take data from infrared sensors, filter out the signal from the false beacon, and obtain the amplitude of the signal. 

My biggest contribution here was that I wrote the firmware to interface with each sensor, and helped debug the circuits that my friends built. It turns out that almost nothing works on the first try, and so I spent quite a long time getting the 7 different types of sensors to work. 

### Software

The C++ firmware that I wrote had control the following
- Two motors for driving
- Servos for the robotic claw
- 19 different sensors
- Motor for our linear actuator
- Motor to move along the zipline
- PID algorithm for following the black tape
- PID algorithm for moving towards the infrared beacon
- Algorithm to follow edge of the platforms
- Putting everything together

Like our robot, if you start in the main file of the repo, you'll probably be initially disgusted by the code. The main file contains a mess of branches, loops, and function calls that describe the exact sequence of steps the robot had to follow. Its pretty messy, and I admit its not easy to follow.

But like our robot, although the firmware is disordered from the outside, upon deeper inspection you'll find that the software is deeply structured. Unlike some other groups that didn't bother, I used object oriented programming to make our code as modular as possible. Each sensor has a class that handles interfacing with the hardware. All but the most high level interaction was abstracted away. For example, the motors could be used simply by specifying the direction, speed, and distance of travel. 

Then, certain key algorithms like the tape and beacon following had their own custom functions written to handle all the details. 

The messiness in the main file was partially because we had to madly scramble near the end of the competition, and there wasn't enough time to make the main function beautiful. However, I think this ended up working out extremely well. 

The reality is that some of the programmers on rival teams got lost in software. In order to achieve something conceptually beautiful, they neglected other important things like validation and testing. For example, many teams spent hours making a state machine with classes and inheritance and all that jazz. However, the time spent getting this to work would have been better spent debugging the software to make it free from errors. Our robot's state machine was a handful of global variables, and all the sensors/motors were global as well. I tested each block of code as I wrote it directly on the competition surface.

That being said, some other teams had the opposite problem. Their code had no structure at all, and was just a rats nest impossible to debug. Our team managed to strike a balance - enough abstractions to simplify programming and make debugging easy, but not overengineered to the point of wasting time.

### Video

Here is a [video](https://drive.google.com/drive/folders/1jlfF5_2Oe6QyQV0OgNqjrnY7Az7M9fHL?usp=sharing) of our robot in action! 

### Takeaways

On the competition day, many teams had robots that couldn't pick up a single idol. Of the other teams, the vast majority got one or two idols. Only three teams got more than four idols. We were the only team that got the gold idol and made it to the finish line.

How? How can it be that after six weeks, a team can be unable to get a single point? The answer is lies in bad planning. Basically, a lot of teams tried to put everything together in the last week of the competition. Some teams only started testing on the competition surface the three days before! It is simply impossible to debug a complex robot in that amount of time. 

Our approach to testing was incremental. We started testing our (incomplete) robot 3 weeks before the competition date. Basically, we focused all our efforts on just getting the first few objectives, before moving on. I believe every team could have got at least the first two idols if they had focused their efforts. But instead they went for an all-or-nothing approach, rather than incrementally making progress. 

Also, during testing we encountered several unexpected problems that took incredibly long to resolve. In particular, it took more than a week before I fixed a problem with one of our sensors.

Hence, I learned the following about engineering
- Avoid trying to put everything together all at once - test things incrementally
- Make sure the basic foundation of your design are working, otherwise you may get nothing accomplished
- Don't underestimate the number of unexpected difficulties you may encounter. The only way to catch these is to empirically test your project far before the target completion date.
- Don't underestimate the time it takes to get basic things working!

Anyway, the joy of winning the competition was obviously great. Yet, in addition to that, the six weeks of development before hand was one of the most fulfilling times of my life. It turns out that if you're doing something you love, working on a project for hundreds of hours can be incredibly fun!

Thank for reading.









---
layout: post
title: "Solving Sudoku"
date: 2025-10-09
description: "Adventures solving sudoku in C and Python"
image: "./assets/sudoku.png"
---

### Overview
My high school used to release math problems biweekly, which could be solved for house points. Although I enjoyed doing most of the problems, for some reason an awful lot of them used to be Sudoku's, which I found rather tedious. We were told that we could solve them using a computer program if we wrote it ourselves.

Years later, I decided that this would be a nice portfolio project. It turned out to be rather fun.

### Process

The first thing I did was figure out what algorithm to use. Normally, there are two ways you can solve a Sudoku by hand. The first method is you try to use logic to deduce what numbers are possible in each square. Often, you can deduce that only 2-4 numbers are possible in certain cells. Then, you can use logic to eliminate possibilities. Using the technique, you almost never have to take guesses, but this would be extremely laborious to code. 

The other technique is a guessing approach. Here, you take a guess and if you make a mistake, you backtrack. 

Funnily enough, Sudoku is actually an NP-complete problem. That is, someone proved for an N x N sudoku, sudoku is computationally identical to other very hard problems that take exponential time to solve. This means that the only algorithms known to solve Sudoku's are slow by nature. 

I decided to take a simple approach and write a depth-first search recursion algorithm. This is a brute force technique. The basic idea is quite simple:
- Pick an square and guess a number.
- Check if that number breaks one of the rules of Sudoku. If it does, try a different guess. 
- If it doesn't, set the square to that number. Move on to a different square, and continue guessing.
- At some later square, you'll probably find that no number works. In this case, you know you made a mistake in the past, so backtrack and change the guess for the previous square. 

Its not hard to show that this algorithm will always find a solution, though its a rather inefficient technique. However, its main attraction is that its very simple to code with recursion. 

To test my solver, I took three Sudoku's from a website (easy, medium and hard) and used them to gauge the effectiveness of my algorithm. I programmed my algorithm using Python. 

### Creating a GUI

I wanted to create a simple GUI that would allow you to plug in numbers into a window. I ended up picking the Python library Tkinter. Though Python is rather slow, it is incredibly easy to use, and the library had everything I needed. Basically, Tkinter uses an object oriented model where you have callback functions that are called when the user does something. It has prebuilt functions for drawing lines and squares. The user clicks on squares and enters numbers, then clicks solve. 

<img src="./assets/sudoku.png" alt="image" width="500"/>

### Initial Results
Solving the easy and medium Sudoku took a few seconds. Solving the hard Sudoku took a full 2 minutes using this algorithm. Terrible!

I decided to tweak my existing algorithm. My original algorithm started guessing at the top right corner, and then went in reading order. When solving Sudoku's by hand, you naturally start with squares that have a lot of known values in the same row, column and box. This is because there are fewer allowed numbers. For a brute force algorithm, it makes sense to make guesses starting in square where a lot of information is already known. 

Hence, before solving the Sudoku, I ranked the squares by the number of known values in the same row, column and box. This means that incorrect guesses are likely to run into issues far faster and thus make fewer incorrect guesses before finding the solution.

After making this change in code, I found that the time to solve to hard Sudoku dropped from 2 minutes to 50 seconds.

At this point, I naturally tried to find ways to speed up my python. I tried
- Using NumPy arrays instead of python lists
- Using a compiled version of python called cython. This required extensively rewriting my code in what was essentially a different language

Alas, these two approaching didn't improve my performance! NumPy is a fantastic library that calls functions written in C, which are much faster than python. However, when solving Sudoku, the main operations are just reading and writing to array elements. It turns out that NumPy isn't faster than native python lists for this - in fact its slower!

Cython was advertised as being a quick and painless way to make python code faster. It turns out this was not the case - even after extensively rewritting my code so that variables had types, and compiling the code specially, it was barely faster than Python! 

### C to the rescue

Fundamentally, Python is not a performant language. Its designed for ease of use. Trying to optimize code in python by using elaborate libraries was taking longer than just rewriting my code in a faster language. 

Hence, I decided to rewrite my code in C. For simplicity, I followed the exact same algorithm. It took a surprisingly small amount of time, because the old code matches almost line by line with the new code, only deviating in places where C is more restrictive than Python.

I then used the Python library ctypes, which allows you to call C functions from python. That way my GUI could be in python, while the intense calculations could be done in C.

This worked! The hard Sudoku takes about 1 second to solve! A 50x improvement simply by rewritting code in a different language. I think this example taught me two things

1. Rewritting performance constrained code in a low level language is genuinly one of the easiest ways to improve performance.
2. Copying code from one language to another is fairly fast. When you first write your code, most of the time is spent figuring out how to solve the problem, debugging, etc. When you write it a second time, you're just reproducing it, so its way faster.

### Conclusion

Overall, I was satisfied with how this project turned out. It ended up taking a few days longer than I expected!

If you want to check out my code, download my code from [here](https://github.com/arandhaw/SudokuSolver). I have both the Python and the C version available. In the command line, navigate to the folder and run "python sudokuSolver.py". 


